# 📘 4.5.4 인덱스 최적화 기법

인덱스 최적화 기법은 DBMS마다 다르지만, 기본 원리는 동일합니다.  
여기서는 MongoDB를 기준으로 설명하지만, 다른 데이터베이스에도 적용 가능합니다.

---

## 1️⃣ 인덱스는 비용이다

- 인덱스는 탐색 속도를 높여주지만, 동시에 **쓰기 성능 저하**와 **추가 저장 공간**을 요구함
- 데이터 수정 시 인덱스도 함께 수정되어야 하므로 **추가 오버헤드** 발생
- 무분별한 인덱스 생성은 오히려 성능 저하 원인 → 자주 조회되는 필드에만 설정하는 것이 효율적

---

## 2️⃣ 항상 테스트하라

- 인덱스 효과는 서비스의 데이터 양·특성에 따라 달라짐  
- 반드시 테스트를 통해 성능 효과를 검증해야 함  

📍 MySQL에서는 `EXPLAIN`으로 쿼리 실행 계획을 확인:

```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1;
```

- 실행 계획을 보고 인덱스가 실제로 사용되는지 확인해야 함

---

## 3️⃣ 복합 인덱스 생성 시 순서 (같음 → 정렬 → 다중 값 → 카디널리티)

복합 인덱스의 생성 순서는 성능에 큰 영향을 줍니다.  
다음 규칙을 따르는 것이 일반적입니다.

1. **같음(Equal) 조건** → `=` 연산에 사용되는 필드 우선
2. **정렬(Order By)** 에 쓰이는 필드
3. **다중 값 조건(Range)** → `>`, `<` 같은 범위 조건에 사용되는 필드
4. **카디널리티(Cardinality)** 높은 필드 → 값이 다양하게 분포된 필드일수록 인덱스 효율성 ↑  
   - 예: `gender(남/여)`보다 `email`처럼 유니크 값이 많은 필드가 효율적

---

## 📌 인덱스 설계 시 주의사항

- 인덱스는 **읽기 성능 향상 ↔ 쓰기 성능 저하**의 트레이드오프 관계
- 인덱스가 많으면 `INSERT`, `UPDATE`, `DELETE` 성능 저하
- 잘못 설계된 인덱스는 오히려 전체 성능을 낮출 수 있음

---

## ✅ 요약

- 인덱스는 탐색을 빠르게 하지만, 쓰기 성능과 저장 공간을 희생함
- 반드시 `EXPLAIN` 등으로 성능을 검증해야 함
- 복합 인덱스는 **같음 → 정렬 → 다중 값 → 카디널리티** 순서로 설계
- MongoDB는 다양한 인덱스(복합, 텍스트, 지리공간 등) 지원